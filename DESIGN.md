Developing EduCafé allowed us to take on a unique programming challenge, in that while our goals were to make the website as easily accessible and simple on the client side as possible, it presented some inherent complexities under the hood that needed to be carefully considered and addressed throughout our development of the backend software.

The front end of the website consists entirely of HTML, CSS, and Javascript. We extensively relied on CSS properties to string together a coherent theme for the website on the whole, which namely centers on moving animations (in the form of GIFs and Webkit animations in CSS), and a white/navy blue/pink color scheme. We also heavily leveraged the ability to separate CSS properties to achieve a more tailored and granular user experience.

The technical complexities of the project arose in its implementation of Javascript and Flask, a Python backend development tool. These two tools proved distinctly challenging––these challenges will be the focus of our reflection today.

Javascript was entirely essential in achieving the dynamic user interface ambitions of the app. To achieve the “swipe-left/swipe-right” Tinder-like feature that allows users to sign up or pass on EduMeets with a simple, intuitive, and fun interaction with the EduMeet card on their screen, we heavily relied on the JQuery Javascript library. We especially found JQuery’s pre-packaged methods, especially the .animate() function, which allows for the animation of CSS objects, extremely useful in abstracting the common steps one would take while learning a more interactive use of the language. We also leveraged Javascript’s ability to track the location of the mouse’s x and y coordinates on the screen to track where the cards were let go of, which thereafter allowed us to determine if the user intended to register for them or pass on them.

The most challenging technical aspect of using Javascript for this web application was eventually integrating its event listeners into the entire app ecosystem, which included the Python Flask backend. The Javascript code is obviously executed after the html template is rendered, so it was difficult to conceptualize how this post-rendering frontend tool could robustly communicate with our backend. We decided to use Javascript’s powerful event listening capabilities, combined with a useful feature of html forms which is that they can be externally tapped and submitted to solve this problem. In other words, we had the main Javascript file for the swiping component of the website listen for an event in which the user indicated they were signing up for an EduMeet by dragging it out to the right enough and then, from the Javascript file itself, tapped into the html form associated with the EduMeet and submitted it alongside hidden inputs. This finally allowed the backend to access the crucial data it needed to process the user’s sign up. 

While the frontend proved challenging, most of all because Javascript is the tool we have had the least experience with and, given the scope of our application, was one we needed intimate familiarity with to succeed in realizing EduCafé, the backend was very intellectually stimulating. 

The backend of the application consists of a Python Flask app.py file and a SQL database, in which there are 4 tables: students, professors, edumeets, and swipes. The default route is to the index page before the UI diverges into two distinct experiences, one for students and one for professors, though these paths do also route back to secondary index pages, so that unless a student or professor is logged out, they will be welcomed onto the website with a more targeted user experience. 

The pages are mostly routed to each other in Flask, with many of the Python functions under the hood making constant queries from the SQL database to pass student, professor, and edumeet data onto the relevant html files. 

Our backend was relatively complicated from the offset. We knew we had to keep track of students and professors in two separate SQL tables within a SQL database, given that the data needs of students and professors on our app are so different they effectively warrant two separate applications. Therefore, two SQL tables, students and professors, were set up to track each respective group. They each contained unique identifiers for each group of users (to allow for viable user sessions to be initiated corresponding to these unique identifiers). As well as these tables, we also created an edumeets database, which kept track of all of the edumeets being posted on the app, including a record of the unique id number of the professor that posted them. This was very helpful as it allowed us to unambiguously and assuredly link the professor to their edumeets, which was crucial for displaying edumeets to students (who we’d then need to immediately email with more information about the professor hosting said edumeets) and fetching edumeets for different purposes. 

Not only that, but given that our app was entirely routed in Flask, the structure of our database became even more important in ensuring that data could be fluidly passed from the front end to the back end and vice versa. One such aspect of this structure that leveraged the very open nature of Flask was the fourth data table we created––swipes. This database purely wrestled with the challenge of having a very dynamic frontend. It effectively keeps track of all of the positive swipes (the sign ups), giving them a column value of 1, whereas it gives the negative swipes (the passes) a column value of 0. As well as this column value, which we called is_interested, it also records the user’s unique identifier (completely enabling the “My EduMeets” section) and the unique identifier (edumeet_id) of the edumeet which was swiped on itself. This is a very neat database-oriented solution to the complications of needing Javascript to manipulate the backend. This is mostly because it allows us to numerically identify which EduMeets have been physically manipulated, or dragged, based on whether or not they are associated with a 0 or 1 in this table. Therefore, this simple yet very effective SQL table enabled us to exit the realm of post-rendering, dynamic client-side development to a more familiar and conventional backend structure. 
As well as thoughtful backend design, we made several specific design decisions based on challenges we faced throughout the iterative coding process. For example, we decided to separate the functions for signing up for an edumeet by swiping on new edumeets (which the user is initially directed to after signing in) and signing up for an edumeet by looking back at an old edumeet. While these may seem like similar processes, in that their outcome is functionally identical, we decided that that they were best separated as not only are their redirections completely different, but in the future, we imagine that the two will tend to diverge more than they seem to now as the app expands, with more or fewer functionalities becoming hinged, as they have been on many other social media platforms, on how loyal and actively engaged a user is with the app’s core functionality. Similarly, we decided to create app routes wherever possible, opting not to render templates within other functions, but rather to redirect to a unique route entirely. We decided on this philosophy because it enables the features of the application to be more easily scalable, meaning they are better engineered in their current state as they require less work to uphold and reinforce in the future. 

Finally, a crucial decision we had to grapple with––which is perhaps one of the few ambitions we set out to achieve that didn’t come at least somewhat to fruition––was the hope of having a lottery system to determine the participants of an edumeet. With that being said, a design decision we did take early on was to implement an email notification system on the backend, which can later be converted to support a lottery system. Despite Gmail banning developers from sending emails from less secure Flask applications very recently, we found a workaround via Outlook, a decision we are proud to have taken given that it supports our long term vision for the app.

Overall, the design of this application, while not intuitive or self explanatory, was stimulating and widely applicable. It gave us a solid grasp of the complex underworkings of the highly data-driven world of social-networks.
